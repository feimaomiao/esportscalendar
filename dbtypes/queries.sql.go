// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package dbtypes

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const gameExist = `-- name: GameExist :one

SELECT COUNT(*) FROM games WHERE id = $1
`

// ============================================================================
// Existence Check Queries
// ============================================================================
func (q *Queries) GameExist(ctx context.Context, id int32) (int64, error) {
	row := q.db.QueryRow(ctx, gameExist, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllGames = `-- name: GetAllGames :many

SELECT id, name, slug
FROM games
WHERE id != 14  -- Exclude specific game
ORDER BY id ASC
`

// ============================================================================
// Basic Retrieval Queries
// ============================================================================
func (q *Queries) GetAllGames(ctx context.Context) ([]Game, error) {
	rows, err := q.db.Query(ctx, getAllGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(&i.ID, &i.Name, &i.Slug); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCalendarMatchesBySelections = `-- name: GetCalendarMatchesBySelections :many

SELECT
    m.id, m.name, m.slug, m.expected_start_time, m.finished,
    m.team1_id, m.team2_id, m.team1_score, m.team2_score, m.amount_of_games,
    m.game_id, m.league_id, m.series_id, m.tournament_id,
    g.name AS game_name,
    l.name AS league_name,
    s.name AS series_name,
    tour.name AS tournament_name,
    tour.tier AS tournament_tier,
    t1.name AS team1_name, t1.acronym AS team1_acronym, t1.image_link AS team1_image,
    t2.name AS team2_name, t2.acronym AS team2_acronym, t2.image_link AS team2_image
FROM matches m
JOIN games g ON m.game_id = g.id
JOIN leagues l ON m.league_id = l.id
JOIN series s ON m.series_id = s.id
JOIN tournaments tour ON m.tournament_id = tour.id
LEFT JOIN teams t1 ON m.team1_id = t1.id
LEFT JOIN teams t2 ON m.team2_id = t2.id
WHERE m.expected_start_time >= NOW() - INTERVAL '3 days'
    AND m.game_id = ANY($1::int[])
    AND (
        (CARDINALITY($2::int[]) > 0 AND (m.team1_id = ANY($2::int[]) OR m.team2_id = ANY($2::int[])))
        OR (CARDINALITY($3::int[]) > 0 AND m.league_id = ANY($3::int[]) AND COALESCE(tour.tier, 0) <= $4::int)
    )
ORDER BY m.expected_start_time ASC
`

type GetCalendarMatchesBySelectionsParams struct {
	GameIds   []int32
	TeamIds   []int32
	LeagueIds []int32
	MaxTier   int32
}

type GetCalendarMatchesBySelectionsRow struct {
	ID                int32
	Name              string
	Slug              pgtype.Text
	ExpectedStartTime pgtype.Timestamp
	Finished          bool
	Team1ID           int32
	Team2ID           int32
	Team1Score        int32
	Team2Score        int32
	AmountOfGames     int32
	GameID            int32
	LeagueID          int32
	SeriesID          int32
	TournamentID      int32
	GameName          string
	LeagueName        string
	SeriesName        string
	TournamentName    string
	TournamentTier    pgtype.Int4
	Team1Name         pgtype.Text
	Team1Acronym      pgtype.Text
	Team1Image        pgtype.Text
	Team2Name         pgtype.Text
	Team2Acronym      pgtype.Text
	Team2Image        pgtype.Text
}

// ============================================================================
// Match Selection Queries (for Calendar Export)
// ============================================================================
func (q *Queries) GetCalendarMatchesBySelections(ctx context.Context, arg GetCalendarMatchesBySelectionsParams) ([]GetCalendarMatchesBySelectionsRow, error) {
	rows, err := q.db.Query(ctx, getCalendarMatchesBySelections,
		arg.GameIds,
		arg.TeamIds,
		arg.LeagueIds,
		arg.MaxTier,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCalendarMatchesBySelectionsRow
	for rows.Next() {
		var i GetCalendarMatchesBySelectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.ExpectedStartTime,
			&i.Finished,
			&i.Team1ID,
			&i.Team2ID,
			&i.Team1Score,
			&i.Team2Score,
			&i.AmountOfGames,
			&i.GameID,
			&i.LeagueID,
			&i.SeriesID,
			&i.TournamentID,
			&i.GameName,
			&i.LeagueName,
			&i.SeriesName,
			&i.TournamentName,
			&i.TournamentTier,
			&i.Team1Name,
			&i.Team1Acronym,
			&i.Team1Image,
			&i.Team2Name,
			&i.Team2Acronym,
			&i.Team2Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFutureMatchesBySelections = `-- name: GetFutureMatchesBySelections :many

SELECT
    m.id, m.name, m.slug, m.expected_start_time, m.finished,
    m.team1_id, m.team2_id, m.team1_score, m.team2_score, m.amount_of_games,
    m.game_id, m.league_id, m.series_id, m.tournament_id,
    g.name AS game_name,
    l.name AS league_name,
    t1.name AS team1_name, t1.acronym AS team1_acronym, t1.image_link AS team1_image,
    t2.name AS team2_name, t2.acronym AS team2_acronym, t2.image_link AS team2_image
FROM matches m
JOIN games g ON m.game_id = g.id
JOIN leagues l ON m.league_id = l.id
JOIN tournaments tour ON m.tournament_id = tour.id
LEFT JOIN teams t1 ON m.team1_id = t1.id
LEFT JOIN teams t2 ON m.team2_id = t2.id
WHERE m.expected_start_time >= NOW()
    AND m.game_id = ANY($1::int[])
    AND (
        (CARDINALITY($2::int[]) > 0 AND (m.team1_id = ANY($2::int[]) OR m.team2_id = ANY($2::int[])))
        OR (CARDINALITY($3::int[]) > 0 AND m.league_id = ANY($3::int[]) AND COALESCE(tour.tier, 0) <= $4::int)
    )
ORDER BY m.expected_start_time ASC
LIMIT $5::int
`

type GetFutureMatchesBySelectionsParams struct {
	GameIds    []int32
	TeamIds    []int32
	LeagueIds  []int32
	MaxTier    int32
	LimitCount int32
}

type GetFutureMatchesBySelectionsRow struct {
	ID                int32
	Name              string
	Slug              pgtype.Text
	ExpectedStartTime pgtype.Timestamp
	Finished          bool
	Team1ID           int32
	Team2ID           int32
	Team1Score        int32
	Team2Score        int32
	AmountOfGames     int32
	GameID            int32
	LeagueID          int32
	SeriesID          int32
	TournamentID      int32
	GameName          string
	LeagueName        string
	Team1Name         pgtype.Text
	Team1Acronym      pgtype.Text
	Team1Image        pgtype.Text
	Team2Name         pgtype.Text
	Team2Acronym      pgtype.Text
	Team2Image        pgtype.Text
}

// ============================================================================
// Match Selection Queries (for Preview)
// ============================================================================
func (q *Queries) GetFutureMatchesBySelections(ctx context.Context, arg GetFutureMatchesBySelectionsParams) ([]GetFutureMatchesBySelectionsRow, error) {
	rows, err := q.db.Query(ctx, getFutureMatchesBySelections,
		arg.GameIds,
		arg.TeamIds,
		arg.LeagueIds,
		arg.MaxTier,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFutureMatchesBySelectionsRow
	for rows.Next() {
		var i GetFutureMatchesBySelectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.ExpectedStartTime,
			&i.Finished,
			&i.Team1ID,
			&i.Team2ID,
			&i.Team1Score,
			&i.Team2Score,
			&i.AmountOfGames,
			&i.GameID,
			&i.LeagueID,
			&i.SeriesID,
			&i.TournamentID,
			&i.GameName,
			&i.LeagueName,
			&i.Team1Name,
			&i.Team1Acronym,
			&i.Team1Image,
			&i.Team2Name,
			&i.Team2Acronym,
			&i.Team2Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeaguesByGameID = `-- name: GetLeaguesByGameID :many
SELECT
    l.id,
    l.name,
    l.slug,
    l.game_id,
    l.image_link,
    MIN(t.tier) AS min_tier
FROM leagues l
LEFT JOIN tournaments t ON l.id = t.league_id
WHERE l.game_id = $1
GROUP BY l.id, l.name, l.slug, l.game_id, l.image_link
ORDER BY MIN(t.tier) ASC, l.name ASC
`

type GetLeaguesByGameIDRow struct {
	ID        int32
	Name      string
	Slug      pgtype.Text
	GameID    int32
	ImageLink pgtype.Text
	MinTier   interface{}
}

func (q *Queries) GetLeaguesByGameID(ctx context.Context, gameID int32) ([]GetLeaguesByGameIDRow, error) {
	rows, err := q.db.Query(ctx, getLeaguesByGameID, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeaguesByGameIDRow
	for rows.Next() {
		var i GetLeaguesByGameIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.GameID,
			&i.ImageLink,
			&i.MinTier,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPastMatchesBySelections = `-- name: GetPastMatchesBySelections :many
SELECT
    id, name, slug, expected_start_time, finished,
    team1_id, team2_id, team1_score, team2_score, amount_of_games,
    game_id, league_id, series_id, tournament_id,
    game_name, league_name,
    team1_name, team1_acronym, team1_image,
    team2_name, team2_acronym, team2_image
FROM (
    SELECT
        m.id, m.name, m.slug, m.expected_start_time, m.finished,
        m.team1_id, m.team2_id, m.team1_score, m.team2_score, m.amount_of_games,
        m.game_id, m.league_id, m.series_id, m.tournament_id,
        g.name AS game_name,
        l.name AS league_name,
        t1.name AS team1_name, t1.acronym AS team1_acronym, t1.image_link AS team1_image,
        t2.name AS team2_name, t2.acronym AS team2_acronym, t2.image_link AS team2_image
    FROM matches m
    JOIN games g ON m.game_id = g.id
    JOIN leagues l ON m.league_id = l.id
    JOIN tournaments tour ON m.tournament_id = tour.id
    LEFT JOIN teams t1 ON m.team1_id = t1.id
    LEFT JOIN teams t2 ON m.team2_id = t2.id
    WHERE m.expected_start_time < NOW()
        AND m.game_id = ANY($1::int[])
        AND (
            (CARDINALITY($2::int[]) > 0 AND (m.team1_id = ANY($2::int[]) OR m.team2_id = ANY($2::int[])))
            OR (CARDINALITY($3::int[]) > 0 AND m.league_id = ANY($3::int[]) AND COALESCE(tour.tier, 0) <= $4::int)
        )
    ORDER BY m.expected_start_time DESC
    LIMIT $5::int
) AS recent_matches
ORDER BY expected_start_time ASC
`

type GetPastMatchesBySelectionsParams struct {
	GameIds    []int32
	TeamIds    []int32
	LeagueIds  []int32
	MaxTier    int32
	LimitCount int32
}

type GetPastMatchesBySelectionsRow struct {
	ID                int32
	Name              string
	Slug              pgtype.Text
	ExpectedStartTime pgtype.Timestamp
	Finished          bool
	Team1ID           int32
	Team2ID           int32
	Team1Score        int32
	Team2Score        int32
	AmountOfGames     int32
	GameID            int32
	LeagueID          int32
	SeriesID          int32
	TournamentID      int32
	GameName          string
	LeagueName        string
	Team1Name         pgtype.Text
	Team1Acronym      pgtype.Text
	Team1Image        pgtype.Text
	Team2Name         pgtype.Text
	Team2Acronym      pgtype.Text
	Team2Image        pgtype.Text
}

func (q *Queries) GetPastMatchesBySelections(ctx context.Context, arg GetPastMatchesBySelectionsParams) ([]GetPastMatchesBySelectionsRow, error) {
	rows, err := q.db.Query(ctx, getPastMatchesBySelections,
		arg.GameIds,
		arg.TeamIds,
		arg.LeagueIds,
		arg.MaxTier,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPastMatchesBySelectionsRow
	for rows.Next() {
		var i GetPastMatchesBySelectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.ExpectedStartTime,
			&i.Finished,
			&i.Team1ID,
			&i.Team2ID,
			&i.Team1Score,
			&i.Team2Score,
			&i.AmountOfGames,
			&i.GameID,
			&i.LeagueID,
			&i.SeriesID,
			&i.TournamentID,
			&i.GameName,
			&i.LeagueName,
			&i.Team1Name,
			&i.Team1Acronym,
			&i.Team1Image,
			&i.Team2Name,
			&i.Team2Acronym,
			&i.Team2Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeriesByGameID = `-- name: GetSeriesByGameID :many
SELECT id, name, slug, game_id, league_id
FROM series
WHERE game_id = $1
ORDER BY name ASC
`

func (q *Queries) GetSeriesByGameID(ctx context.Context, gameID int32) ([]Series, error) {
	rows, err := q.db.Query(ctx, getSeriesByGameID, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Series
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.GameID,
			&i.LeagueID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsByGameID = `-- name: GetTeamsByGameID :many
SELECT id, name, slug, acronym, image_link, game_id
FROM teams
WHERE game_id = $1
ORDER BY name ASC
`

func (q *Queries) GetTeamsByGameID(ctx context.Context, gameID int32) ([]Team, error) {
	rows, err := q.db.Query(ctx, getTeamsByGameID, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Acronym,
			&i.ImageLink,
			&i.GameID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getURLMapping = `-- name: GetURLMapping :one
SELECT hashed_key, value_list, access_count, created_at, accessed_at
FROM url_mappings
WHERE hashed_key = $1
`

func (q *Queries) GetURLMapping(ctx context.Context, hashedKey string) (UrlMapping, error) {
	row := q.db.QueryRow(ctx, getURLMapping, hashedKey)
	var i UrlMapping
	err := row.Scan(
		&i.HashedKey,
		&i.ValueList,
		&i.AccessCount,
		&i.CreatedAt,
		&i.AccessedAt,
	)
	return i, err
}

const insertToGames = `-- name: InsertToGames :exec

INSERT INTO games (id, name, slug)
VALUES ($1, $2, $3)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug
`

type InsertToGamesParams struct {
	ID   int32
	Name string
	Slug pgtype.Text
}

// ============================================================================
// INSERT/UPSERT Queries
// ============================================================================
func (q *Queries) InsertToGames(ctx context.Context, arg InsertToGamesParams) error {
	_, err := q.db.Exec(ctx, insertToGames, arg.ID, arg.Name, arg.Slug)
	return err
}

const insertToLeagues = `-- name: InsertToLeagues :exec
INSERT INTO leagues (id, name, slug, image_link, game_id)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    image_link = EXCLUDED.image_link,
    game_id = EXCLUDED.game_id
`

type InsertToLeaguesParams struct {
	ID        int32
	Name      string
	Slug      pgtype.Text
	ImageLink pgtype.Text
	GameID    int32
}

func (q *Queries) InsertToLeagues(ctx context.Context, arg InsertToLeaguesParams) error {
	_, err := q.db.Exec(ctx, insertToLeagues,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.ImageLink,
		arg.GameID,
	)
	return err
}

const insertToMatches = `-- name: InsertToMatches :exec
INSERT INTO matches (
    id, name, slug, finished, expected_start_time, actual_game_time,
    team1_id, team1_score, team2_id, team2_score, amount_of_games,
    game_id, league_id, series_id, tournament_id
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    finished = EXCLUDED.finished,
    expected_start_time = EXCLUDED.expected_start_time,
    actual_game_time = EXCLUDED.actual_game_time,
    team1_id = EXCLUDED.team1_id,
    team1_score = EXCLUDED.team1_score,
    team2_id = EXCLUDED.team2_id,
    team2_score = EXCLUDED.team2_score,
    amount_of_games = EXCLUDED.amount_of_games,
    game_id = EXCLUDED.game_id,
    league_id = EXCLUDED.league_id,
    series_id = EXCLUDED.series_id,
    tournament_id = EXCLUDED.tournament_id
`

type InsertToMatchesParams struct {
	ID                int32
	Name              string
	Slug              pgtype.Text
	Finished          bool
	ExpectedStartTime pgtype.Timestamp
	ActualGameTime    float64
	Team1ID           int32
	Team1Score        int32
	Team2ID           int32
	Team2Score        int32
	AmountOfGames     int32
	GameID            int32
	LeagueID          int32
	SeriesID          int32
	TournamentID      int32
}

func (q *Queries) InsertToMatches(ctx context.Context, arg InsertToMatchesParams) error {
	_, err := q.db.Exec(ctx, insertToMatches,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Finished,
		arg.ExpectedStartTime,
		arg.ActualGameTime,
		arg.Team1ID,
		arg.Team1Score,
		arg.Team2ID,
		arg.Team2Score,
		arg.AmountOfGames,
		arg.GameID,
		arg.LeagueID,
		arg.SeriesID,
		arg.TournamentID,
	)
	return err
}

const insertToSeries = `-- name: InsertToSeries :exec
INSERT INTO series (id, name, slug, game_id, league_id)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    game_id = EXCLUDED.game_id,
    league_id = EXCLUDED.league_id
`

type InsertToSeriesParams struct {
	ID       int32
	Name     string
	Slug     pgtype.Text
	GameID   int32
	LeagueID int32
}

func (q *Queries) InsertToSeries(ctx context.Context, arg InsertToSeriesParams) error {
	_, err := q.db.Exec(ctx, insertToSeries,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.GameID,
		arg.LeagueID,
	)
	return err
}

const insertToTeams = `-- name: InsertToTeams :exec
INSERT INTO teams (id, name, slug, acronym, image_link, game_id)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    acronym = EXCLUDED.acronym,
    image_link = EXCLUDED.image_link,
    game_id = EXCLUDED.game_id
`

type InsertToTeamsParams struct {
	ID        int32
	Name      string
	Slug      pgtype.Text
	Acronym   pgtype.Text
	ImageLink pgtype.Text
	GameID    int32
}

func (q *Queries) InsertToTeams(ctx context.Context, arg InsertToTeamsParams) error {
	_, err := q.db.Exec(ctx, insertToTeams,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Acronym,
		arg.ImageLink,
		arg.GameID,
	)
	return err
}

const insertToTournaments = `-- name: InsertToTournaments :exec
INSERT INTO tournaments (id, name, slug, tier, game_id, league_id, serie_id)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    tier = EXCLUDED.tier,
    game_id = EXCLUDED.game_id,
    league_id = EXCLUDED.league_id,
    serie_id = EXCLUDED.serie_id
`

type InsertToTournamentsParams struct {
	ID       int32
	Name     string
	Slug     pgtype.Text
	Tier     pgtype.Int4
	GameID   int32
	LeagueID int32
	SerieID  int32
}

func (q *Queries) InsertToTournaments(ctx context.Context, arg InsertToTournamentsParams) error {
	_, err := q.db.Exec(ctx, insertToTournaments,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Tier,
		arg.GameID,
		arg.LeagueID,
		arg.SerieID,
	)
	return err
}

const insertURLMapping = `-- name: InsertURLMapping :exec

INSERT INTO url_mappings (hashed_key, value_list, access_count, created_at, accessed_at)
VALUES ($1, $2, 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT (hashed_key) DO NOTHING
`

type InsertURLMappingParams struct {
	HashedKey string
	ValueList []byte
}

// ============================================================================
// URL Mapping Queries (for Calendar Links)
// ============================================================================
func (q *Queries) InsertURLMapping(ctx context.Context, arg InsertURLMappingParams) error {
	_, err := q.db.Exec(ctx, insertURLMapping, arg.HashedKey, arg.ValueList)
	return err
}

const leagueExist = `-- name: LeagueExist :one
SELECT COUNT(*) FROM leagues WHERE id = $1
`

func (q *Queries) LeagueExist(ctx context.Context, id int32) (int64, error) {
	row := q.db.QueryRow(ctx, leagueExist, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const matchExist = `-- name: MatchExist :one
SELECT COUNT(*) FROM matches WHERE id = $1
`

func (q *Queries) MatchExist(ctx context.Context, id int32) (int64, error) {
	row := q.db.QueryRow(ctx, matchExist, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const seriesExist = `-- name: SeriesExist :one
SELECT COUNT(*) FROM series WHERE id = $1
`

func (q *Queries) SeriesExist(ctx context.Context, id int32) (int64, error) {
	row := q.db.QueryRow(ctx, seriesExist, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const teamExist = `-- name: TeamExist :one
SELECT COUNT(*) FROM teams WHERE id = $1
`

func (q *Queries) TeamExist(ctx context.Context, id int32) (int64, error) {
	row := q.db.QueryRow(ctx, teamExist, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const tournamentExist = `-- name: TournamentExist :one
SELECT COUNT(*) FROM tournaments WHERE id = $1
`

func (q *Queries) TournamentExist(ctx context.Context, id int32) (int64, error) {
	row := q.db.QueryRow(ctx, tournamentExist, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateURLMappingAccessCount = `-- name: UpdateURLMappingAccessCount :exec
UPDATE url_mappings
SET access_count = access_count + 1, accessed_at = CURRENT_TIMESTAMP
WHERE hashed_key = $1
`

func (q *Queries) UpdateURLMappingAccessCount(ctx context.Context, hashedKey string) error {
	_, err := q.db.Exec(ctx, updateURLMappingAccessCount, hashedKey)
	return err
}
