// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package dbtypes

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const gameExist = `-- name: GameExist :one
SELECT COUNT(*) FROM games WHERE id = $1
`

func (q *Queries) GameExist(ctx context.Context, id int32) (int64, error) {
	row := q.db.QueryRow(ctx, gameExist, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllGames = `-- name: GetAllGames :many
SELECT id, name, slug FROM games WHERE (id != 14) ORDER BY id ASC
`

func (q *Queries) GetAllGames(ctx context.Context) ([]Game, error) {
	rows, err := q.db.Query(ctx, getAllGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Game
	for rows.Next() {
		var i Game
		if err := rows.Scan(&i.ID, &i.Name, &i.Slug); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeaguesByGameID = `-- name: GetLeaguesByGameID :many
SELECT l.id, l.name, l.slug, l.game_id, l.image_link, MIN(t.tier) as min_tier
FROM LEAGUES l
LEFT JOIN TOURNAMENTS t ON l.id = t.league_id
WHERE l.game_id = $1
GROUP BY l.id, l.name, l.slug, l.game_id, l.image_link
ORDER BY MIN(t.tier) ASC, l.name ASC
`

type GetLeaguesByGameIDRow struct {
	ID        int32
	Name      string
	Slug      pgtype.Text
	GameID    int32
	ImageLink pgtype.Text
	MinTier   interface{}
}

func (q *Queries) GetLeaguesByGameID(ctx context.Context, gameID int32) ([]GetLeaguesByGameIDRow, error) {
	rows, err := q.db.Query(ctx, getLeaguesByGameID, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeaguesByGameIDRow
	for rows.Next() {
		var i GetLeaguesByGameIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.GameID,
			&i.ImageLink,
			&i.MinTier,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchesBySelections = `-- name: GetMatchesBySelections :many
SELECT
    m.id,
    m.name,
    m.slug,
    m.expected_start_time,
    m.finished,
    m.team1_id,
    m.team2_id,
    m.team1_score,
    m.team2_score,
    m.amount_of_games,
    m.game_id,
    m.league_id,
    m.series_id,
    m.tournament_id,
    g.name as game_name,
    l.name as league_name,
    t1.name as team1_name,
    t1.acronym as team1_acronym,
    t1.image_link as team1_image,
    t2.name as team2_name,
    t2.acronym as team2_acronym,
    t2.image_link as team2_image
FROM matches m
INNER JOIN games g ON m.game_id = g.id
INNER JOIN leagues l ON m.league_id = l.id
INNER JOIN teams t1 ON m.team1_id = t1.id
INNER JOIN teams t2 ON m.team2_id = t2.id
WHERE
    m.expected_start_time >= NOW() - INTERVAL '7 days'
    AND m.expected_start_time <= NOW() + INTERVAL '7 days'
    AND m.game_id = ANY($1::int[])
    AND (
        (CARDINALITY($2::int[]) = 0 OR m.league_id = ANY($2::int[]))
        OR (CARDINALITY($3::int[]) = 0 OR m.team1_id = ANY($3::int[]) OR m.team2_id = ANY($3::int[]))
    )
ORDER BY m.expected_start_time ASC
`

type GetMatchesBySelectionsParams struct {
	GameIds   []int32
	LeagueIds []int32
	TeamIds   []int32
}

type GetMatchesBySelectionsRow struct {
	ID                int32
	Name              string
	Slug              pgtype.Text
	ExpectedStartTime pgtype.Timestamp
	Finished          bool
	Team1ID           int32
	Team2ID           int32
	Team1Score        int32
	Team2Score        int32
	AmountOfGames     int32
	GameID            int32
	LeagueID          int32
	SeriesID          int32
	TournamentID      int32
	GameName          string
	LeagueName        string
	Team1Name         string
	Team1Acronym      pgtype.Text
	Team1Image        pgtype.Text
	Team2Name         string
	Team2Acronym      pgtype.Text
	Team2Image        pgtype.Text
}

func (q *Queries) GetMatchesBySelections(ctx context.Context, arg GetMatchesBySelectionsParams) ([]GetMatchesBySelectionsRow, error) {
	rows, err := q.db.Query(ctx, getMatchesBySelections, arg.GameIds, arg.LeagueIds, arg.TeamIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMatchesBySelectionsRow
	for rows.Next() {
		var i GetMatchesBySelectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.ExpectedStartTime,
			&i.Finished,
			&i.Team1ID,
			&i.Team2ID,
			&i.Team1Score,
			&i.Team2Score,
			&i.AmountOfGames,
			&i.GameID,
			&i.LeagueID,
			&i.SeriesID,
			&i.TournamentID,
			&i.GameName,
			&i.LeagueName,
			&i.Team1Name,
			&i.Team1Acronym,
			&i.Team1Image,
			&i.Team2Name,
			&i.Team2Acronym,
			&i.Team2Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeriesByGameID = `-- name: GetSeriesByGameID :many
SELECT id, name, slug, game_id, league_id FROM series WHERE game_id = $1 ORDER BY name ASC
`

func (q *Queries) GetSeriesByGameID(ctx context.Context, gameID int32) ([]Series, error) {
	rows, err := q.db.Query(ctx, getSeriesByGameID, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Series
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.GameID,
			&i.LeagueID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsByGameID = `-- name: GetTeamsByGameID :many
SELECT id, name, slug, acronym, image_link, game_id
FROM teams
WHERE game_id = $1
ORDER BY name ASC
`

func (q *Queries) GetTeamsByGameID(ctx context.Context, gameID int32) ([]Team, error) {
	rows, err := q.db.Query(ctx, getTeamsByGameID, gameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Acronym,
			&i.ImageLink,
			&i.GameID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertToGames = `-- name: InsertToGames :exec
INSERT INTO games (id, name, slug) VALUES ($1, $2, $3) ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug
`

type InsertToGamesParams struct {
	ID   int32
	Name string
	Slug pgtype.Text
}

func (q *Queries) InsertToGames(ctx context.Context, arg InsertToGamesParams) error {
	_, err := q.db.Exec(ctx, insertToGames, arg.ID, arg.Name, arg.Slug)
	return err
}

const insertToLeagues = `-- name: InsertToLeagues :exec
INSERT INTO leagues (id, name, slug, image_link, game_id) VALUES ($1, $2, $3, $4, $5) ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    image_link = EXCLUDED.image_link,
    game_id = EXCLUDED.game_id
`

type InsertToLeaguesParams struct {
	ID        int32
	Name      string
	Slug      pgtype.Text
	ImageLink pgtype.Text
	GameID    int32
}

func (q *Queries) InsertToLeagues(ctx context.Context, arg InsertToLeaguesParams) error {
	_, err := q.db.Exec(ctx, insertToLeagues,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.ImageLink,
		arg.GameID,
	)
	return err
}

const insertToMatches = `-- name: InsertToMatches :exec
INSERT INTO matches (id, name, slug, finished, expected_start_time, actual_game_time, team1_id, team1_score, team2_id, team2_score, amount_of_games, game_id, league_id, series_id, tournament_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15) ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    finished = EXCLUDED.finished,
    expected_start_time = EXCLUDED.expected_start_time,
    actual_game_time = EXCLUDED.actual_game_time,
    team1_id = EXCLUDED.team1_id,
    team1_score = EXCLUDED.team1_score,
    team2_id = EXCLUDED.team2_id,
    team2_score = EXCLUDED.team2_score,
    amount_of_games = EXCLUDED.amount_of_games,
    game_id = EXCLUDED.game_id,
    league_id = EXCLUDED.league_id,
    series_id = EXCLUDED.series_id,
    tournament_id = EXCLUDED.tournament_id
`

type InsertToMatchesParams struct {
	ID                int32
	Name              string
	Slug              pgtype.Text
	Finished          bool
	ExpectedStartTime pgtype.Timestamp
	ActualGameTime    float64
	Team1ID           int32
	Team1Score        int32
	Team2ID           int32
	Team2Score        int32
	AmountOfGames     int32
	GameID            int32
	LeagueID          int32
	SeriesID          int32
	TournamentID      int32
}

func (q *Queries) InsertToMatches(ctx context.Context, arg InsertToMatchesParams) error {
	_, err := q.db.Exec(ctx, insertToMatches,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Finished,
		arg.ExpectedStartTime,
		arg.ActualGameTime,
		arg.Team1ID,
		arg.Team1Score,
		arg.Team2ID,
		arg.Team2Score,
		arg.AmountOfGames,
		arg.GameID,
		arg.LeagueID,
		arg.SeriesID,
		arg.TournamentID,
	)
	return err
}

const insertToSeries = `-- name: InsertToSeries :exec
INSERT INTO series (id, name, slug, game_id, league_id) VALUES ($1, $2, $3, $4, $5) ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    game_id = EXCLUDED.game_id,
    league_id = EXCLUDED.league_id
`

type InsertToSeriesParams struct {
	ID       int32
	Name     string
	Slug     pgtype.Text
	GameID   int32
	LeagueID int32
}

func (q *Queries) InsertToSeries(ctx context.Context, arg InsertToSeriesParams) error {
	_, err := q.db.Exec(ctx, insertToSeries,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.GameID,
		arg.LeagueID,
	)
	return err
}

const insertToTeams = `-- name: InsertToTeams :exec
INSERT INTO teams (id, name, slug, acronym, image_link, game_id) VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    acronym = EXCLUDED.acronym,
    image_link = EXCLUDED.image_link,
    game_id = EXCLUDED.game_id
`

type InsertToTeamsParams struct {
	ID        int32
	Name      string
	Slug      pgtype.Text
	Acronym   pgtype.Text
	ImageLink pgtype.Text
	GameID    int32
}

func (q *Queries) InsertToTeams(ctx context.Context, arg InsertToTeamsParams) error {
	_, err := q.db.Exec(ctx, insertToTeams,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Acronym,
		arg.ImageLink,
		arg.GameID,
	)
	return err
}

const insertToTournaments = `-- name: InsertToTournaments :exec
INSERT INTO tournaments (id,name, slug,tier, game_id, league_id, serie_id) VALUES ($1, $2, $3, $4, $5, $6, $7) ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    slug = EXCLUDED.slug,
    tier = EXCLUDED.tier,
    game_id = EXCLUDED.game_id,
    league_id = EXCLUDED.league_id,
    serie_id = EXCLUDED.serie_id
`

type InsertToTournamentsParams struct {
	ID       int32
	Name     string
	Slug     pgtype.Text
	Tier     pgtype.Int4
	GameID   int32
	LeagueID int32
	SerieID  int32
}

func (q *Queries) InsertToTournaments(ctx context.Context, arg InsertToTournamentsParams) error {
	_, err := q.db.Exec(ctx, insertToTournaments,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Tier,
		arg.GameID,
		arg.LeagueID,
		arg.SerieID,
	)
	return err
}

const leagueExist = `-- name: LeagueExist :one
SELECT COUNT(*) FROM leagues WHERE id = $1
`

func (q *Queries) LeagueExist(ctx context.Context, id int32) (int64, error) {
	row := q.db.QueryRow(ctx, leagueExist, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const matchExist = `-- name: MatchExist :one
SELECT COUNT(*) FROM matches WHERE id = $1
`

func (q *Queries) MatchExist(ctx context.Context, id int32) (int64, error) {
	row := q.db.QueryRow(ctx, matchExist, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const seriesExist = `-- name: SeriesExist :one
SELECT COUNT(*) FROM series WHERE id = $1
`

func (q *Queries) SeriesExist(ctx context.Context, id int32) (int64, error) {
	row := q.db.QueryRow(ctx, seriesExist, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const teamExist = `-- name: TeamExist :one
SELECT COUNT(*) FROM teams WHERE id = $1
`

func (q *Queries) TeamExist(ctx context.Context, id int32) (int64, error) {
	row := q.db.QueryRow(ctx, teamExist, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const tournamentExist = `-- name: TournamentExist :one
SELECT COUNT(*) FROM tournaments WHERE id = $1
`

func (q *Queries) TournamentExist(ctx context.Context, id int32) (int64, error) {
	row := q.db.QueryRow(ctx, tournamentExist, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}
